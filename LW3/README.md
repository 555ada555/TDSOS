# Лабораторна робота 3
## ТЕМА
Проєктування спеціалізованої RTOS для Інтернету речей на платформі Raspberry Pi. Реалізація рівнів привілеїв. Апаратне налагодження по JTAG. Реалізація рівнів привілеїв. Тестування на реальній платформі.
## ЗАВДАННЯ
Складний рівень. Реалізувати етапи 8, 9 проєктування спеціалізованої RTOS для платформи Raspberry Pi3. Протестувати поточну версію ядра та зробити відповідні висновки. Пояснити відмінності реалізації для платформи Raspberry Pi4. Оформити звіт з виконаної роботи.
## Етап 8.
•	Виконайте команду make jtagboot і залиште термінал відкритим.
•	Підключіть пристрій USB для послідовного з'єднання.
•	Підключіть USB-пристрій для JTAG-дебагу.
•	У новому терміналі виконайте команду make openocd і залиште термінал відкритим.
•	У новому терміналі виконайте команду make gdb або make gdb-opt0.
### Результат:
Після завантаження, завдяки змінам, які були внесені в config.txt, програмне забезпечення пристрою RPi налаштує відповідні GPIO-піни для функціональності JTAG.
Далі слід зупинити виконання RPi і підключитись через JTAG. Для цього слід додати нову ціль у файл Makefile, make jtagboot, яка використовує підхід chainboot для завантаження невеликого допоміжного бінарного файлу на пристрій RPi, який просто переводить виконуюче ядро в стан очікування.
Допоміжний бінарний файл зберігається окремо у папці X1_JTAG_boot цього репозиторію і є зміненою версією ядра.
## Етап 9. 
На цьому етапі виконується налаштування апаратного забезпечення за допомогою JTAG. Для цього слід виконати такі кроки:
•	Виконати команду "make jtagboot" і тримати термінал відкритим.
•	Підключити кабель USB для послідовного порту.
•	Підключити JTAG-пристрій через USB.
•	В новому терміналі виконати команду "make openocd" і залишити його відкритим.
•	В новому терміналі виконати команду "make gdb" або "make gdb-opt0".
У першу чергу потрібно переконатись, що дійсно робота виконується в EL2, перш ніж викликати відповідний код для переходу до EL1. Тому слід додати нову перевірку в самому початку boot.s, яка припиняє виконання ядра, якщо CPU-ядру не вдалося перейти до EL2.
mrs	x0, CurrentEL
cmp	x0, {CONST_CURRENTEL_EL2}
b.ne	.L_parking_loop
Після цього слід продовжити підготовку переходу з EL2 в EL1, викликаючи функцію prepare_el2_to_el1_transition() в файлі boot.rs.
#[no_mangle]
pub unsafe extern "C" fn _start_rust(phys_boot_core_stack_end_exclusive_addr: u64) -> ! {
    prepare_el2_to_el1_transition(phys_boot_core_stack_end_exclusive_addr);
    asm::eret()
}
Оскільки EL2 має більший рівень привілеїв, ніж EL1, він має контроль над різними функціями процесора і може дозволяти або забороняти використання ними коду EL1. Один з прикладів - доступ до регістрів таймера і лічильника. Їх слід зберегти, для цього слід встановити відповідні прапорці в регістрі керування гіпервізором таймера і лічильника (Counter-timer Hypervisor Control register) і додатково встановити віртуальне зміщення (virtual offset) на нуль, щоб отримувати реальне фізичне значення кожного разу:
CNTHCTL_EL2.write(CNTHCTL_EL2::EL1PCEN::SET + CNTHCTL_EL2::EL1PCTEN::SET);
CNTVOFF_EL2.set(0);
Далі слід налаштувати регістр конфігурації гіпервізора (Hypervisor Configuration Register) таким чином, щоб EL1 працював в режимі AArch64, а не AArch32, що також було б можливим.
### Результат:
У файлі main.rs слід ввести поточний рівень привілеїв і додатково перевірити, чи біти маски в регістрі SPSR_EL2 також передані в EL1.
